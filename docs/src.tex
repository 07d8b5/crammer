\documentclass[11pt,oneside,openany]{book}
\usepackage[margin=1in]{geometry}
\usepackage{iftex}
\ifPDFTeX
	\usepackage[T1]{fontenc}
\else
	\usepackage{fontspec}
	\setmainfont{Latin Modern Roman}
	\setsansfont{Latin Modern Sans}
	\setmonofont{Latin Modern Mono}
\fi
\usepackage{xurl}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{microtype}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{longtable}
\usepackage{array}
\usepackage{tocloft}

\newif\ifdraft
% Set to \drafttrue for an internal working draft (shows editor notes).
\draftfalse
\newcommand{\draftnote}[2]{%
	\ifdraft
	\par\smallskip
	\noindent\begingroup\small\sloppy
	\color{gray}
	\textbf{DRAFT NOTE (#1):} #2%
	\endgroup
	\par\smallskip
	\fi
}

\newenvironment{evidenceblock}[4]{%
	\begin{quote}\small\sloppy
		\textbf{Claim:} #1\\
		\textbf{Source:} \path{#2}\\
		\textbf{Symbol/Addr:} \path{#3}\\
		\textbf{Notes:} #4\\
	}{\end{quote}}

\hypersetup{hidelinks}
\urlstyle{same}
\pdfstringdefDisableCommands{%
	\def\path#1{#1}%
	\def\filep#1{#1}%
	\def\sym#1{#1}%
	\def\off#1{#1}%
}
% Encourage line breaks in long \path/\url runs (paths, symbols, IDs).
\Urlmuskip=0mu plus 2mu\relax
\DeclareRobustCommand{\sym}[1]{\path{#1}}
\DeclareRobustCommand{\filep}[1]{\path{#1}}
\newcommand{\off}[1]{\texttt{#1}}
\newcommand{\purpose}[1]{\par\noindent\textbf{Purpose.} #1\par}
\newcommand{\sowhat}[1]{%
	\par\smallskip
	\noindent\textbf{So what?} #1\par
	\smallskip
}
\newcommand{\definition}[2]{%
	\begin{quote}\small\sloppy
		\textbf{Definition (#1).} #2
	\end{quote}
}
\newcommand{\pitfall}[2]{%
	\begin{quote}\small\sloppy
		\textbf{Pitfall (#1).} #2
	\end{quote}
}
\newcommand{\chapterroadmap}[2]{%
	\begin{quote}\small\sloppy
		\textbf{Roadmap.} #1
		\par\medskip
		\textbf{You should leave this chapter able to:}
		\begin{itemize}#2\end{itemize}
	\end{quote}
}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{1}
\raggedbottom
\setlength{\emergencystretch}{3em}
\setlength{\headheight}{14pt}

%======================================================================
% LISTINGS (CODE EXCERPTS)
%======================================================================
\lstdefinestyle{cramc}{%
	language=C,
	basicstyle=\ttfamily\small,
	columns=fullflexible,
	breaklines=true,
	breakatwhitespace=false,
	showstringspaces=false,
	upquote=true,
	frame=single,
	rulecolor=\color{black!15},
	keywordstyle=\color{black},
	commentstyle=\color{black!60},
	stringstyle=\color{black},
	tabsize=8
}
\lstset{style=cramc}

%======================================================================
% PAGE STYLE
%======================================================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textit{cram}}
\fancyhead[R]{\textit{\leftmark}}
\fancyfoot[C]{\thepage}

%======================================================================
% DOCUMENT METADATA
%======================================================================
\title{\textbf{cram}\\\large Source Walkthrough (\filep{src/})}
\author{Repository: \filep{crammer/} \quad Companion: \filep{docs/crammer.tex}}
\date{\today}

\begin{document}
\frontmatter
\maketitle
\tableofcontents

%======================================================================
% PREFACE
%======================================================================
\chapter{Preface: what this document is}
\purpose{Walk through every C translation unit in \filep{src/} and explain how the pieces fit together: structure, invariants, error handling, and the design constraints that shape the code.}

This is a source-level guide. It does not try to restate the user manual; it tries to answer engineering questions:
\begin{itemize}
	\item Where is the program entry point and what does it call?
	\item Where is state stored and what are its lifetimes?
	\item Which invariants are enforced by construction vs by checking?
	\item How do parsing, randomness, timing, terminal I/O, and logging compose?
\end{itemize}

\definition{Repository root}{Throughout this document, file paths are relative to the repository root directory \filep{crammer/}.}
\definition{Module}{A single \off{.c} file in \filep{src/} and its corresponding \off{.h} file in \filep{include/}.}

%======================================================================
% CHAPTER 1
%======================================================================
\mainmatter
\chapter{Orientation: how control flows through \filep{src/}}
\chapterroadmap{
This chapter gives you the high-level call graph and the responsibilities of each file.
}{
	\item Identify the entry point and sequencing.
	\item Know where parsing ends and runtime begins.
	\item Understand which modules own which side effects.
}

\section{The top-level call graph}
At a coarse level the program is a pipeline:
\begin{quote}\small\sloppy
\filep{src/main.c} \(\rightarrow\) \sym{app\_run\_file} (\filep{src/app.c}) \(\rightarrow\)
parse \(\rightarrow\) log open \(\rightarrow\) RNG init \(\rightarrow\) run loop \(\rightarrow\) log close.
\end{quote}

\begin{evidenceblock}
{The CLI entry point delegates almost all work to \sym{app\_run\_file}.}
{src/main.c, include/app.h}
{\sym{main}, \sym{app\_run\_file}}
{\filep{src/main.c} calls \sym{app\_run\_file(argv[1])} after validating arguments.}
\end{evidenceblock}

\subsection*{Code excerpt: entry point}
\begin{lstlisting}
int main(int argc, char **argv)
{
	...
	if (argc != 2) {
		int rc = print_usage(argv[0]);
		return (rc == 0) ? 1 : 2;
	}
	return (app_run_file(argv[1]) == 0) ? 0 : 1;
}
\end{lstlisting}

\begin{evidenceblock}
{\sym{app\_run\_file} sequences parse \(\rightarrow\) log open \(\rightarrow\) RNG init \(\rightarrow\) runner \(\rightarrow\) log close.}
{src/app.c}
{\sym{app\_run\_file}}
{This function is the “orchestrator”: it does not implement the runtime loop; it calls into other modules.}
\end{evidenceblock}

\subsection*{Code excerpt: orchestration}
\begin{lstlisting}
int app_run_file(const char *path)
{
	int rc = setup_session(path);
	if (rc != 0)
		return -1;
	rc = log_open(&g_app.session);
	if (rc != 0)
		return -1;
	rc = rng_init(&g_app.rng);
	if (rc != 0)
		return -1;
	rc = runner_run(&g_app.session, &g_app.rng,
			g_app.group_order, MAX_GROUPS,
			g_app.item_order, MAX_ITEMS_PER_GROUP);
	...
	return 0;
}
\end{lstlisting}

\section{Module map}
\begin{longtable}{>{\raggedright\arraybackslash}p{0.22\linewidth} >{\raggedright\arraybackslash}p{0.70\linewidth}}
\textbf{File} & \textbf{Responsibility}\\\hline
\filep{src/main.c} & CLI argument handling; prints usage; calls \sym{app\_run\_file}.\\
\filep{src/app.c} & Owns the long-lived static app state; sequences parse/log/RNG/runner.\\
\filep{src/model.c} & Initializes \sym{struct Session}.\\
\filep{src/parser.c} & Reads a session file into a buffer and parses it into groups/items.\\
\filep{src/rng.c} & RNG state, seeding, unbiased range selection, shuffles.\\
\filep{src/term.c} & Raw terminal entry/restore and timed single-byte key reads.\\
\filep{src/log.c} & Append-only log file writing with timestamps and tags.\\
\filep{src/runner.c} & The runtime loop: timers, group switching, prompt display, and key handling.\\
\end{longtable}

\sowhat{If you are debugging a behavior, start by classifying it: parse-time (parser/model) vs run-time (runner/term/rng/log) vs wiring (main/app).}

%======================================================================
% CHAPTER 2
%======================================================================
\chapter{Cross-cutting design constraints}
\chapterroadmap{
This chapter explains the non-negotiables: bounded memory, bounded loops, and the project’s “defensive C” conventions.
}{
	\item Recognize the compile-time bounds that shape all data structures.
	\item Understand how asserts/validations are used in this codebase.
	\item Spot the “no unbounded loops” pattern in I/O and runtime code.
}

\section{Compile-time bounds and static storage}
The repository defines its “maximum universe” in \filep{include/config.h}. These constants determine:
\begin{itemize}
	\item Maximum number of groups and items stored in memory.
	\item Maximum accepted file size and line length.
	\item Maximum number of iterations for loops that could otherwise spin.
\end{itemize}

\begin{evidenceblock}
{The core data structures are statically sized by compile-time constants such as \sym{MAX\_GROUPS}, \sym{MAX\_ITEMS\_TOTAL}, and \sym{MAX\_FILE\_BYTES}.}
{include/config.h, include/model.h}
{\sym{MAX\_GROUPS}, \sym{MAX\_ITEMS\_TOTAL}, \sym{MAX\_FILE\_BYTES}, \sym{struct Session}}
{\filep{include/model.h} embeds the buffer/groups/items arrays directly in \sym{struct Session}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_CONFIG_MAX_GROUP_SECONDS_V1]
% % CLAIM="The maximum allowed group timer duration is configured by MAX_GROUP_SECONDS; the parser enforces it when parsing headers and the runner relies on it for time computations and sanity bounds."
% % STATE=UNVERIFIED
% % NEEDS_RESEARCH=YES
% % GAPS="Need excerpt from include/config.h defining MAX_GROUP_SECONDS/MAX_GROUP_MILLISECONDS and the compile-time consistency check; need excerpts from src/parser.c parse_seconds_value and src/runner.c (update_group_timer/read_key) showing the enforcement/assumptions."
% % NEXT_ACTION="Extract a 10–40 line excerpt from include/config.h around MAX_GROUP_SECONDS/MAX_GROUP_MILLISECONDS and the related static_assert; then extract short excerpts from src/parser.c parse_seconds_value (secs > MAX_GROUP_SECONDS) and src/runner.c update_group_timer/read_key (seconds->ms and remaining_ms bound)."
% % SEARCH_TERMS="MAX_GROUP_SECONDS MAX_GROUP_MILLISECONDS static_assert_max_group_ms secs > MAX_GROUP_SECONDS rt->group_end = now + (u64)seconds * 1000ULL remaining_ms <= MAX_GROUP_MILLISECONDS"
% % EVIDENCE="TODO: EX excerpt(s) from include/config.h, src/parser.c, src/runner.c"
% % CONF=0
% %@END

\subsection*{Code excerpt: max group duration bounds (TODO)}
\begin{lstlisting}
/* TODO: EXCERPT (10–40 lines) showing MAX_GROUP_SECONDS/MAX_GROUP_MILLISECONDS and their enforcement:
 * - include/config.h: MAX_GROUP_SECONDS + derived MAX_GROUP_MILLISECONDS + static assert
 * - src/parser.c: secs > MAX_GROUP_SECONDS
 * - src/runner.c: remaining_ms <= MAX_GROUP_MILLISECONDS and/or group_end computation
 * SEARCH_TERMS: MAX_GROUP_SECONDS MAX_GROUP_MILLISECONDS static_assert_max_group_ms secs > MAX_GROUP_SECONDS remaining_ms <= MAX_GROUP_MILLISECONDS
 */
\end{lstlisting}

\section{Validation vs assertion}
\filep{include/config.h} provides tiny helpers that appear throughout the source:
\begin{itemize}
	\item \sym{validate\_ptr}/\sym{validate\_ok}: used for input checking and early returns.
	\item \sym{assert\_ptr}/\sym{assert\_ok}: used as “should be true here” internal checks.
\end{itemize}

% %@RS[ID=SRC_RS_ASSERT_VALIDATE_SAME_IMPL_V1]
% % CLAIM="The assertion helpers and validation helpers currently compile to identical behavior (no abort/logging), so they only communicate intent."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="static inline int assert_ok static inline int validate_ok assert_ptr validate_ptr"
% % EVIDENCE="See include/config.h excerpt below showing the helper bodies."
% % CONF=2
% %@END

\begin{evidenceblock}
{The code distinguishes “validation” helpers (\sym{validate\_...}) from “assertion” helpers (\sym{assert\_...}), and uses them broadly for control-flow checks.}
{include/config.h}
{\sym{validate\_ok}, \sym{validate\_ptr}, \sym{assert\_ok}, \sym{assert\_ptr}}
{Both families currently compile to the same behavior (boolean checks); the distinction is semantic and shows intent.}
\end{evidenceblock}

\subsection*{Code excerpt: assert vs validate}
\begin{lstlisting}
static inline int assert_ok(int cond)
{
	return cond ? 1 : 0;
}

static inline int assert_ptr(const void *ptr)
{
	return ptr ? 1 : 0;
}

static inline int validate_ok(int cond)
{
	return cond ? 1 : 0;
}

static inline int validate_ptr(const void *ptr)
{
	return ptr ? 1 : 0;
}
\end{lstlisting}

These four helpers are the codebase’s “micro-contract” language. The excerpt shows that \sym{assert\_ok}/\sym{assert\_ptr} and \sym{validate\_ok}/\sym{validate\_ptr} are currently identical at the machine level: they return \off{1} for true/non-null and \off{0} for false/null. There is no logging, abort, or side effect baked into either family.

So why have two sets? The answer is intent. Calls written as \sym{validate\_...} are meant to guard external inputs and return early when the caller violated a precondition (e.g., \off{NULL} pointers or invalid ranges). Calls written as \sym{assert\_...} mark internal invariants: conditions the author believes should always hold at that point in the control flow.

This distinction is valuable even without enforcement because it makes audits and reviews faster: you can skim a function and immediately see which checks are defensive input validation versus which are “this would indicate a bug” sanity checks. It also leaves room for future tightening (for example, compiling \sym{assert\_...} differently under a debug build) without changing call sites.

\section{Bounded loops in I/O paths}
Several modules implement retry loops that are explicitly capped:
\begin{itemize}
	\item \filep{src/term.c}: \sym{write\_all} caps retries with \sym{MAX\_WRITE\_LOOPS}.
	\item \filep{src/log.c}: writing the log line caps retries with \sym{MAX\_WRITE\_LOOPS}.
	\item \filep{src/runner.c}: the main wait loop is capped by \sym{MAX\_WAIT\_LOOPS}.
\end{itemize}

\begin{evidenceblock}
{Potentially-blocking loops that retry on \off{EINTR} are capped by \sym{MAX\_WRITE\_LOOPS} or \sym{MAX\_WAIT\_LOOPS}.}
{src/term.c, src/log.c, src/runner.c, include/config.h}
{\sym{MAX\_WRITE\_LOOPS}, \sym{MAX\_WAIT\_LOOPS}}
{This is a deliberate “fail instead of spin forever” posture.}
\end{evidenceblock}

\sowhat{This code is built to be audit-friendly: it uses fixed storage and explicit bounds to keep behavior predictable even under error conditions.}

%======================================================================
% CHAPTER 3
%======================================================================
\chapter{The in-memory model: \filep{include/model.h} and \filep{src/model.c}}
\chapterroadmap{
This chapter explains the core storage model: one buffer, plus offset/length slices into that buffer.
}{
	\item Understand \sym{struct Session} layout and lifetimes.
	\item Understand how groups and items reference text without extra allocations.
	\item Understand why offsets are used instead of pointers in the persisted model.
}

\section{The “buffer + slices” pattern}
\sym{struct Session} contains:
\begin{itemize}
	\item A file buffer of \sym{MAX\_FILE\_BYTES + 1} bytes.
	\item Arrays of \sym{struct Group} and \sym{struct Item}.
	\item Counts (\sym{group\_count}, \sym{item\_count}) tracking how much is used.
\end{itemize}

\begin{evidenceblock}
{Groups and items store offsets/lengths into a single session buffer rather than allocating per-line strings.}
{include/model.h}
{\sym{struct Session}, \sym{struct Group}, \sym{struct Item}}
{\sym{struct Group} and \sym{struct Item} use \off{u32} offsets/lengths.}
\end{evidenceblock}

\section{Initialization}
\filep{src/model.c} provides \sym{session\_init}, which resets all counts and buffer length.

\begin{evidenceblock}
{\sym{session\_init} resets \sym{buffer\_len}, \sym{group\_count}, and \sym{item\_count} to zero.}
{src/model.c}
{\sym{session\_init}}
{This is the only explicit initialization step before parsing.}
\end{evidenceblock}

\subsection*{Code excerpt: session initialization}
\begin{lstlisting}
int session_init(struct Session *session)
{
	session->buffer_len = 0;
	session->group_count = 0;
	session->item_count = 0;
	return 0;
}
\end{lstlisting}

\sowhat{Because offsets refer into a single stable buffer, parsing is allocation-free after the initial read, and the runtime only needs the session object to display prompts.}

%======================================================================
% CHAPTER 4
%======================================================================
\chapter{Parsing: \filep{src/parser.c}}
\chapterroadmap{
This chapter walks from “read bytes from disk” to “validated session in memory”.
}{
	\item Follow the parsing pipeline (\sym{parse\_session\_file} \(\rightarrow\) read \(\rightarrow\) parse).
	\item Understand how header lines and item lines are recognized.
	\item Understand the failure modes and the error-buffer strategy.
}

\section{Parsing pipeline}
The top-level entry point is \sym{parse\_session\_file}. It calls:
\begin{itemize}
	\item \sym{session\_init} to reset state.
	\item \sym{read\_file\_into\_session} to populate the buffer.
	\item \sym{parse\_session\_buffer} to scan and interpret lines.
\end{itemize}

% %@RS[ID=SRC_RS_PARSER_BUFFER_NUL_TERM_V1]
% % CLAIM="After reading the session file, the parser NUL-terminates the buffer at buffer_len so later parsing can safely write temporary terminators."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="read_file_into_session session->buffer[nread] = '\\0' fread MAX_FILE_BYTES"
% % EVIDENCE="See read_file_into_session() excerpt below showing the overflow check and NUL terminator write."
% % CONF=2
% %@END

\begin{evidenceblock}
{\sym{parse\_session\_file} initializes the session, reads the file into \sym{session->buffer}, then parses the buffer line-by-line.}
{src/parser.c}
{\sym{parse\_session\_file}, \sym{read\_file\_into\_session}, \sym{parse\_session\_buffer}}
{The buffer is NUL-terminated after read to allow safe temporary line termination during parsing.}
\end{evidenceblock}

\subsection*{Code excerpt: file read + NUL terminator}
\begin{lstlisting}
static int read_file_into_session(const char *path, struct Session *session,
				  char *err_buf, size_t err_len)
{
	...
	size_t nread = fread(session->buffer, 1, MAX_FILE_BYTES, fp);
	...
	int extra = fgetc(fp);

	if (extra != EOF) {
		...
		return set_error(err_buf, err_len,
				 "file exceeds MAX_FILE_BYTES");
	}
	...
	session->buffer_len = nread;
	session->buffer[nread] = '\0';
	return 0;
}
\end{lstlisting}

The parser reads the session file into \sym{session->buffer} with a fixed upper bound (\sym{MAX\_FILE\_BYTES}). The excerpt shows the core pattern: read up to the limit via \sym{fread}, then attempt one more byte via \sym{fgetc}. If that extra byte exists, the file is too large; the function closes the file and returns a structured parse error (\off{"file exceeds MAX\_FILE\_BYTES"}).

Two lines at the bottom matter for later parsing correctness: \sym{session->buffer\_len = nread} records how many bytes were read, and \sym{session->buffer[nread] = '\\0'} appends a terminator. This terminator is not part of the session file; it is a convenience for the parser implementation.

Specifically, later code in \sym{parse\_session\_buffer} writes temporary \off{'\\0'} bytes at line boundaries (and inside headers) to parse substrings without allocating new strings. Adding a final terminator ensures these temporary C-string operations cannot run off the end of the buffer even when the input file has no trailing newline.

\section{Error reporting model}
Parsing functions take an \off{err\_buf} and \off{err\_len}. On error they populate the buffer and return \off{-1}.

\begin{evidenceblock}
{Errors during parsing are reported by writing a message into a caller-provided buffer via helpers like \sym{set\_error\_line}.}
{src/parser.c}
{\sym{set\_error}, \sym{set\_error\_line}}
{\sym{set\_error\_line} prefixes errors with \off{Line <n>:}.}
\end{evidenceblock}

\section{Line scanning and CRLF normalization}
\sym{parse\_session\_buffer} scans for \off{\\textbackslash n}. If a line ends with \off{\\textbackslash r} before \off{\\textbackslash n}, the \off{\\textbackslash r} is excluded from the logical line length.

\begin{evidenceblock}
{If a line ends with \off{\\textbackslash r} before \off{\\textbackslash n}, \sym{parse\_session\_buffer} reduces the line length by one (CRLF normalization).}
{src/parser.c}
{\sym{parse\_session\_buffer}}
{The check is against \off{session->buffer[line\_start + line\_len - 1]}.}
\end{evidenceblock}

\subsection*{Code excerpt: line scanning}
\begin{lstlisting}
for (size_t i = 0; i <= MAX_FILE_BYTES; i++) {
	if (i == session->buffer_len || session->buffer[i] == '\n') {
		size_t line_len = i - line_start;
		if (line_len > 0 &&
		    session->buffer[line_start + line_len - 1] == '\r')
			line_len--;
		...
		line[line_len] = '\0';
		int rc = handle_line(session, &state, line,
				    line_len, line_start,
				    err_buf, err_len);
		...
	}
}
\end{lstlisting}

\section{Header vs item lines}
The parser distinguishes:
\begin{itemize}
	\item Group header lines: \off{[<name> | <seconds>]}.
	\item Item lines: any non-blank, non-comment line that is not a header.
	\item Comments: lines whose first non-whitespace character is \off{\#}.
\end{itemize}

% %@RS[ID=SRC_RS_PARSER_ITEM_BEFORE_HEADER_V1]
% % CLAIM="If the parser encounters a non-blank, non-comment item line before any group header, it fails with the line-anchored error 'item before any group header'."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="item before any group header !state->has_group parse_item_line handle_line return set_error_line"
% % EVIDENCE="See excerpt below showing parse_item_line() rejecting !state->has_group and handle_line() dispatch for non-header lines."
% % CONF=2
% %@END

\subsection*{Code excerpt: item before header rejection}
\begin{lstlisting}
static int parse_item_line(struct Session *session, struct parse_state *state,
			   size_t line_start, size_t line_len,
			   char *err_buf, size_t err_len)
{
	...
	if (!state->has_group)
		return set_error_line(err_buf, err_len, state->line_no,
				      "item before any group header");
	...
}

static int handle_line(struct Session *session, struct parse_state *state,
		       char *line, size_t line_len, size_t line_start,
		       char *err_buf, size_t err_len)
{
	...
	if (is_blank_or_comment(line, line_len))
		return 0;
	if (line[0] == '[') {
		...
		state->has_group = 1;
		return 0;
	}
	return parse_item_line(session, state, line_start, line_len,
			       err_buf, err_len);
}
\end{lstlisting}

This excerpt answers a basic file-format question: may a session file contain items before the first header? The answer is no, and the failure mode is explicit and line-anchored.

The enforcement lives in \sym{parse\_item\_line}, not in the line classifier. That split is intentional: \sym{handle\_line} remains a small dispatcher (“blank/comment”, “header”, “otherwise item”), while \sym{parse\_item\_line} enforces the structural precondition \off{state->has\_group}.

The error string (\off{"item before any group header"}) is produced via \sym{set\_error\_line}, which includes the current line number. That makes malformed input self-diagnosing: the user can jump straight to the offending line instead of inferring structure from downstream behavior.

Finally, note what this choice buys the runtime. If parsing succeeds, the runner never needs to consider “orphan items”: every stored item is associated with some group by construction, and the only group-related edge cases left are those already checked elsewhere (such as empty groups, which are rejected separately).

\begin{evidenceblock}
{Blank lines and comment lines are ignored; a comment line is one whose first non-space character is \off{\#}.}
{src/parser.c}
{\sym{is\_blank\_or\_comment}}
{Whitespace trimming uses \sym{trim\_left\_index} and \sym{trim\_right\_index}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_PARSER_COMMENT_BLANK_RULE_EXCERPT_V1]
% % CLAIM="The parser treats a line as ignorable if, after trimming leading whitespace, it is empty or begins with '#'."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="is_blank_or_comment trim_left_index line[start] == '#'"
% % EVIDENCE="See the is_blank_or_comment() excerpt below showing trim_left_index and the '#' test."
% % CONF=2
% %@END

\subsection*{Code excerpt: comment/blank line rule}
\begin{lstlisting}
static int is_blank_or_comment(const char *line, size_t line_len)
{
	if (!validate_ptr(line))
		return 1;
	if (!validate_ok(line_len <= MAX_LINE_LEN))
		return 1;

	size_t start = trim_left_index(line, line_len);

	if (start >= line_len)
		return 1;
	return line[start] == '#';
}
\end{lstlisting}

This function defines the parser’s “ignorable line” policy. First, it treats invalid inputs (\off{NULL} pointers or absurd lengths) as ignorable by returning \off{1}; that keeps callers simple because they can assume “invalid line” behaves like “blank line” rather than needing a separate error path.

The core rule is the \sym{trim\_left\_index} call. It computes the first non-whitespace position in the line. If the entire line is whitespace (\off{start >= line\_len}), the function returns true: it is blank.

Otherwise the rule is a single character test: if the first non-space byte is \off{\#}, the line is a comment. Everything else is “content” and must be interpreted either as a header or as an item line. This “only if first non-space is \#” detail matters: \off{\#} in the middle of a prompt is not special; it is preserved as part of the item text.

% %@RS[ID=SRC_RS_PARSER_ITEM_STORAGE_NO_TRIM_V1]
% % CLAIM="The parser preserves item lines exactly as scanned (minus CRLF normalization): it stores item offsets/lengths without trimming leading/trailing whitespace."
% % STATE=UNVERIFIED
% % NEEDS_RESEARCH=YES
% % GAPS="Need excerpt showing parse_item_line storing offset/length directly (line_start/line_len) and that trimming helpers are not applied to item content."
% % NEXT_ACTION="Extract a 10–40 line excerpt from src/parser.c covering parse_item_line() and the handle_line() call that passes line_start/line_len, and confirm CRLF normalization happens earlier in parse_session_buffer()."
% % SEARCH_TERMS="static int parse_item_line item->offset = (u32)line_start item->length = (u32)line_len handle_line return parse_item_line session->item_count++ group->item_count++"
% % EVIDENCE="TODO: EX excerpt from src/parser.c parse_item_line"
% % CONF=0
% %@END

\subsection*{Code excerpt: item storage (no trimming) (TODO)}
\begin{lstlisting}
/* TODO: EXCERPT (10–40 lines) from src/parser.c parse_item_line():
 * show: item->offset/length assigned from line_start/line_len and counters incremented.
 * SEARCH_TERMS: item->offset = (u32)line_start item->length = (u32)line_len session->item_count++ group->item_count++
 */
\end{lstlisting}

% %@RS[ID=SRC_RS_PARSER_TRIM_FUNCTIONS_EXCERPT_V1]
% % CLAIM="Whitespace trimming is implemented by trim_left_index (first non-space) and trim_right_index (exclusive end index after removing trailing spaces, but never before start), both bounded by MAX_LINE_LEN."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="static size_t trim_left_index static size_t trim_right_index isspace MAX_LINE_LEN"
% % EVIDENCE="See excerpt below showing trim_left_index() and trim_right_index() bounds checks and isspace scans."
% % CONF=2
% %@END

\subsection*{Code excerpt: trimming helpers}
\begin{lstlisting}
static size_t trim_left_index(const char *line, size_t line_len)
{
	if (!validate_ptr(line))
		return line_len;
	if (!validate_ok(line_len <= MAX_LINE_LEN))
		return line_len;

	for (size_t i = 0; i < line_len; i++) {
		if (!isspace((unsigned char)line[i]))
			return i;
	}
	return line_len;
}

static size_t trim_right_index(const char *line, size_t line_len, size_t start)
{
	if (!validate_ptr(line))
		return start;
	if (!validate_ok(line_len <= MAX_LINE_LEN))
		return start;

	size_t end = line_len;

	for (size_t i = 0; i < line_len; i++) {
		if (end <= start || end == 0)
			break;
		if (!isspace((unsigned char)line[end - 1]))
			break;
		end--;
	}
	return end;
}
\end{lstlisting}

These two helpers define what “trimmed” means everywhere else in the parser. They do not allocate or copy; they compute indices into the existing line buffer, and callers slice using those indices.

\sym{trim\_left\_index} is straightforward: it returns the first position whose byte is not \sym{isspace} (after the standard \off{(unsigned char)} cast). If the line is all whitespace, it returns \sym{line\_len}, which matches how callers already treat \off{start >= line\_len} as blank.

\sym{trim\_right\_index} is slightly more nuanced. It returns an \emph{exclusive} end index (\sym{end}) such that \off{[start, end)} contains the trimmed content. The guard \off{end <= start} means it will never “trim past” the caller-chosen start index; if you pass \sym{start} from \sym{trim\_left\_index}, the combined effect is “strip leading whitespace, then strip trailing whitespace, but never underflow”.

Both helpers enforce the same bound (\sym{MAX\_LINE\_LEN}). That matters because the rest of the parser assumes it can run these scans without pathological cost: the bound turns “scan the whole line” into a predictable, limited operation.

\begin{evidenceblock}
{A header line is recognized by leading \off{[}, trailing \off{]}, and a \off{|} separator inside.}
{src/parser.c}
{\sym{parse\_header\_line}, \sym{find\_pipe\_index}}
{\sym{parse\_header\_line} temporarily NUL-terminates the name and seconds substrings by writing \off{'\\textbackslash0'} into the buffer.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_PARSER_FIND_PIPE_INDEX_RULE_V1]
% % CLAIM="Header parsing requires a '|' that is neither the first nor last character of the line; find_pipe_index scans indices 1..line_len-2."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="static int find_pipe_index i = 1 i + 1 < line_len out_index"
% % EVIDENCE="See excerpt below showing find_pipe_index() scanning i=1..line_len-2 and writing *out_index."
% % CONF=2
% %@END

\subsection*{Code excerpt: pipe index rule}
\begin{lstlisting}
static int find_pipe_index(const char *line, size_t line_len,
			   size_t *out_index)
{
	if (!validate_ptr(line))
		return -1;
	if (!validate_ptr(out_index))
		return -1;

	for (size_t i = 1; i + 1 < line_len && i < MAX_LINE_LEN; i++) {
		if (line[i] == '|') {
			*out_index = i;
			return 0;
		}
	}
	return -1;
}
\end{lstlisting}

This helper encodes a subtle but important syntactic rule: the \off{|} separator must be in the \emph{interior} of the header line. Starting the scan at \off{i = 1} intentionally skips the first character (which should be \off{[}), and the guard \off{i + 1 < line\_len} ensures \off{|} cannot be the last character of the line.

The \sym{MAX\_LINE\_LEN} condition is a second line of defense. Even if a caller accidentally passes an untrusted \sym{line\_len}, the function will not scan more than the configured maximum. In practice, earlier validation already enforces the bound, but keeping it here makes the helper safe in isolation.

Finally, the output contract is explicit: on the first \off{|} found, \sym{*out\_index} is written and the function returns success. If no valid separator exists, it returns failure, which lets \sym{parse\_header\_line} treat malformed headers as “not a header” (or as an error, depending on how the caller reports it) without needing special cases for “pipe at the edge”.

\subsection*{Code excerpt: header split}
\begin{lstlisting}
line[line_len - 1] = '\0';
line[pipe_index] = '\0';

char *name = line + 1;
...
char *sec = line + pipe_index + 1;
...
rc = parse_seconds_value(sec, line_no, err_buf, err_len, &seconds);
\end{lstlisting}

% %@RS[ID=SRC_RS_PARSER_BUFFER_MUTATION_V1]
% % CLAIM="Parsing mutates the session buffer by inserting NUL bytes (line terminators and header field splits), so later code must treat the buffer as a blob with embedded NULs and rely on stored offsets/lengths."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="line[line_len] = '\\0' line[pipe_index] = '\\0' line[line_len - 1] = '\\0'"
% % EVIDENCE="See excerpt below showing line termination in parse_session_buffer() and header field splitting in parse_header_line()."
% % CONF=2
% %@END

\begin{evidenceblock}
{The parser mutates \sym{session->buffer} by writing NUL bytes to temporarily split lines and header fields during parsing.}
{src/parser.c}
{\sym{parse\_session\_buffer}, \sym{parse\_header\_line}}
{The writes are \off{line[line\_len] = '\\textbackslash0'} for line termination and \off{line[pipe\_index] = '\\textbackslash0'} for header splitting.}
\end{evidenceblock}

\subsection*{Code excerpt: buffer mutation}
\begin{lstlisting}
/* parse_session_buffer() */
char *line = &session->buffer[line_start];

line[line_len] = '\0';
int rc = handle_line(session, &state, line,
		    line_len, line_start,
		    err_buf, err_len);

/* parse_header_line() */
line[line_len - 1] = '\0';
line[pipe_index] = '\0';

char *name = line + 1;
...
char *sec = line + pipe_index + 1;
\end{lstlisting}

The excerpt shows the core tradeoff of this parser: it uses the session buffer as both storage and a scratchpad. In \sym{parse\_session\_buffer}, each detected line is temporarily NUL-terminated (\off{line[line\_len] = '\\0'}) so downstream helpers can treat the line as a C string without allocating new memory.

Headers require a second kind of split. \sym{parse\_header\_line} overwrites the closing bracket and the pipe separator with NUL bytes, turning \off{[name|seconds]} into two adjacent strings inside the same buffer: \off{name} and \off{sec}. That makes subsequent trimming and numeric parsing straightforward.

This mutation is why the persistent session model stores offsets and lengths (\sym{struct Group} and \sym{struct Item}) rather than pointers to C strings: after parsing, \sym{session->buffer} is no longer a single NUL-terminated text blob, but a blob with embedded terminators. The runtime therefore uses offsets/lengths to print exact prompt bytes (including any internal punctuation) rather than depending on C-string semantics.

\section{Seconds parsing}
\sym{parse\_seconds\_value} parses seconds as base-10 via \sym{strtoul} and rejects values outside \off{[1, MAX\_GROUP\_SECONDS]}. (The default is one day, but the cap is tunable via \sym{MAX\_GROUP\_SECONDS} in \filep{include/config.h}.)

\begin{evidenceblock}
{The per-group seconds value must parse as a decimal integer in the range \off{1..MAX\_GROUP\_SECONDS}.}
{src/parser.c}
{\sym{parse\_seconds\_value}}
{\sym{parse\_seconds\_value} checks \sym{errno}, \sym{endptr}, and bounds.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_PARSER_SECONDS_PARSE_EXCERPT_V1]
% % CLAIM="Seconds are parsed with strtoul, require full-string consumption, and are rejected if outside 1..MAX_GROUP_SECONDS."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="parse_seconds_value strtoul secs < 1 secs > MAX_GROUP_SECONDS endptr != '\\0' errno"
% % EVIDENCE="See the parse_seconds_value() excerpt below showing errno/endptr validation and the MAX_GROUP_SECONDS bound."
% % CONF=2
% %@END

\subsection*{Code excerpt: seconds parsing}
\begin{lstlisting}
static int parse_seconds_value(const char *sec, size_t line_no,
			       char *err_buf, size_t err_len,
			       unsigned int *out_seconds)
{
	...
	errno = 0;
	char *endptr = NULL;
	unsigned long secs = strtoul(sec, &endptr, 10);

	if (errno != 0 || !endptr || *endptr != '\0' || secs < 1 ||
	    secs > MAX_GROUP_SECONDS)
		return set_error_line(err_buf, err_len, line_no,
				      "invalid seconds value");
	*out_seconds = (unsigned int)secs;
	return 0;
}
\end{lstlisting}

This function is a tight “parse and validate” gate. It uses \sym{strtoul} to parse the seconds field as a base-10 unsigned integer and then applies three layers of validation.

First, it enforces clean parsing: \sym{errno} must remain zero, and \sym{endptr} must point at the terminating NUL byte (\off{*endptr == '\\0'}). That second condition is what rejects strings like \off{60s} or \off{10 20}: the parse must consume the entire seconds substring produced by header splitting and trimming.

Second, it enforces a semantic range: values must be within \off{1..MAX\_GROUP\_SECONDS}. This makes a group timer always positive, and it prevents extremely long timers unless you intentionally raise \sym{MAX\_GROUP\_SECONDS}. When the check fails, the error is anchored to the current line number via \sym{set\_error\_line} and the caller gets a specific message: \off{"invalid seconds value"}.

\section{Enforced limits}
Parsing rejects files that exceed configured bounds: maximum file bytes, maximum line length, maximum number of groups, maximum total items, and maximum items per group.

\begin{evidenceblock}
{Parsing fails fast when file size, line length, group count, or item counts exceed compile-time limits.}
{include/config.h, src/parser.c}
{\sym{MAX\_FILE\_BYTES}, \sym{MAX\_LINE\_LEN}, \sym{MAX\_GROUPS}, \sym{MAX\_ITEMS\_TOTAL}, \sym{MAX\_ITEMS\_PER\_GROUP}}
{The checks appear in \sym{read\_file\_into\_session}, \sym{parse\_session\_buffer}, \sym{parse\_header\_line}, and \sym{parse\_item\_line}.}
\end{evidenceblock}

\section{Structural validity: groups must have items}

% %@RS[ID=SRC_RS_PARSER_EMPTY_GROUP_CHECKS_V1]
% % CLAIM="The parser rejects sessions where a group has zero items (both for intermediate groups and for the final group)."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="previous group has no items last group has no items handle_line parse_session_buffer"
% % EVIDENCE="See excerpt below showing the previous-group and last-group empty checks and their error strings."
% % CONF=2
% %@END

The parser is strict about session structure: a group header must be followed by at least one item line before another group header (or EOF) is accepted.

\begin{evidenceblock}
{The parser rejects any group that contains zero items, both when a new header appears and at end-of-file.}
{src/parser.c}
{\sym{handle\_line}, \sym{parse\_session\_buffer}}
{The error strings are \off{"previous group has no items"} and \off{"last group has no items"}.}
\end{evidenceblock}

\subsection*{Code excerpt: empty-group rejection}
\begin{lstlisting}
static int handle_line(...)
{
	...
	if (line[0] == '[') {
		if (state->has_group) {
			const struct Group *group =
				&session->groups[state->current_group];
			if (group->item_count == 0)
				return set_error_line(err_buf, err_len,
						      state->line_no,
						      "previous group has no items");
		}
		...
	}
	...
}

static int parse_session_buffer(...)
{
	...
	if (state.has_group) {
		const struct Group *group =
			&session->groups[state.current_group];
		if (group->item_count == 0)
			return set_error_line(err_buf, err_len, state.line_no,
					      "last group has no items");
	}
	...
}
\end{lstlisting}

The key design choice here is \emph{early structural rejection}. In \sym{handle\_line}, the parser only allows a new header line if the \emph{previous} group has received at least one item. It does this at the moment it sees the next \off{[...|...]} header, because that is the first time it can be sure the previous group is “finished” (no more items will be attached to it).

The second check closes the loophole at end-of-file. If the file ends immediately after a header (or after blank/comment lines that do not count as items), there is no “next header” to trigger the previous-group check. \sym{parse\_session\_buffer} therefore performs a final validation after the line scan, rejecting a trailing empty group with the explicit error \off{"last group has no items"}.

Together these checks establish an invariant the runtime can rely on: every \sym{struct Group} described by the session has at least one corresponding \sym{struct Item}. That simplifies later code: the runner can assert that per-group item counts are non-zero without needing to handle “empty group” as a special case.

\sowhat{Because the parser writes NULs into the buffer while processing, any “string” pointers produced during parsing are treated as temporary; the persistent model is offsets/lengths into the original buffer.}

%======================================================================
% CHAPTER 5
%======================================================================
\chapter{Randomness and shuffling: \filep{src/rng.c}}
\chapterroadmap{
This chapter explains how the program generates pseudo-randomness and uses it to shuffle groups and items.
}{
	\item Understand seeding strategy and fallback behavior.
	\item Understand unbiased range selection.
	\item Understand the shuffle loops and their bounds.
}

\section{Seeding}
\sym{rng\_init} prefers \filep{/dev/urandom}. If it fails or reads short, it falls back to combining realtime clock and PID, then mixes the seed before storing it in \sym{rng->state}.

\begin{evidenceblock}
{\sym{rng\_init} attempts to seed from \filep{/dev/urandom} and falls back to \off{CLOCK\_REALTIME} and \sym{getpid()}.}
{src/rng.c}
{\sym{rng\_init}}
{If \filep{/dev/urandom} cannot be read fully, the code forces \off{seed = 0} and uses the fallback path.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_RNG_INIT_SEED_FALLBACK_EXCERPT_V1]
% % CLAIM="rng_init uses /dev/urandom when available; otherwise it derives a seed from CLOCK_REALTIME and PID, then applies a mixing function and forces a non-zero state."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="int rng_init open(\"/dev/urandom\" seed == 0 clock_gettime getpid mix64 rng->state == 0"
% % EVIDENCE="See the rng_init() excerpt below showing urandom seeding, seed==0 fallback, mixing, and non-zero state fixup."
% % CONF=2
% %@END

\subsection*{Code excerpt: \sym{rng\_init} seeding}
\begin{lstlisting}
int rng_init(struct Rng *rng)
{
	...
	u64 seed = 0;
	int fd = open("/dev/urandom", O_RDONLY);

	if (fd >= 0) {
		size_t want = sizeof(seed);
		ssize_t got = read(fd, &seed, want);
		int rc = close(fd);

		if (rc != 0)
			seed = 0;
		if (got != (ssize_t)want)
			seed = 0;
	}
	if (seed == 0) {
		struct timespec ts;
		int rc = clock_gettime(CLOCK_REALTIME, &ts);

		if (rc != 0) {
			ts.tv_sec = 0;
			ts.tv_nsec = 0;
		}
		seed = (u64)ts.tv_nsec ^ ((u64)ts.tv_sec << 32) ^
		       (u64)getpid();
	}
	rng->state = mix64(seed);
	if (rng->state == 0)
		rng->state = 0x9e3779b97f4a7c15ULL;
	return 0;
}
\end{lstlisting}

The RNG initialization code is written to be robust rather than cryptographic. It prefers a kernel-provided seed (\filep{/dev/urandom}) and validates that the read succeeded in full: if closing the file fails or if the read is short, it discards the seed and takes the fallback path.

The fallback path is explicit and local: it samples realtime clock (\off{CLOCK\_REALTIME}) and combines it with the process ID using XOR and a shift. If even the clock read fails, it falls back again to a zeroed \sym{timespec}, which still yields a non-constant seed because \sym{getpid()} contributes entropy on most systems.

Finally, the seed is mixed through \sym{mix64} and forced non-zero. That last guard is important because the underlying generator assumes \sym{rng->state != 0}; setting a fixed non-zero constant ensures the program does not get stuck in an all-zero state even if every seeding attempt fails.

\section{Range selection}
\sym{rng\_range} computes a threshold and retries up to \sym{RNG\_RETRY\_LIMIT} times to avoid modulo bias.

\begin{evidenceblock}
{\sym{rng\_range} uses a threshold and retries up to \sym{RNG\_RETRY\_LIMIT} to implement a bias-resistant mapping from \sym{u64} to \off{[0, upper)}.}
{src/rng.c, include/config.h}
{\sym{rng\_range}, \sym{RNG\_RETRY\_LIMIT}}
{After retries, it falls back to a direct modulo of the next RNG output.}
\end{evidenceblock}

\subsection*{Code excerpt: unbiased range}
\begin{lstlisting}
u64 threshold = (u64)(-upper) % upper;

for (size_t i = 0; i < RNG_RETRY_LIMIT; i++) {
	u64 r = rng_next_u64(rng);
	if (r >= threshold)
		return (size_t)(r % upper);
}
return (size_t)(rng_next_u64(rng) % upper);
\end{lstlisting}

\section{Shuffling}
The shuffle helpers implement a bounded Fisher--Yates-style loop from \off{i=1..count-1} where \off{j} is selected from \off{[0..i]}.

\begin{evidenceblock}
{\sym{rng\_shuffle\_groups} and \sym{rng\_shuffle\_items} shuffle by swapping each position \off{i} with a random \off{j} in \off{[0..i]}.}
{src/rng.c}
{\sym{rng\_shuffle\_groups}, \sym{rng\_shuffle\_items}}
{Both loops are bounded by \sym{MAX\_GROUPS} or \sym{MAX\_ITEMS\_PER\_GROUP} and stop at \off{count}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_RNG_SHUFFLE_LOOP_EXCERPT_V1]
% % CLAIM="rng_shuffle_groups/items implement an in-place Fisher–Yates-style shuffle: for i from 1..count-1, pick j in [0..i] and swap values[i] with values[j]."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="rng_shuffle_items rng_shuffle_groups for (size_t i = 1 j = rng_range swap"
% % EVIDENCE="See excerpt below showing the shuffle loops’ i=1 start, j=rng_range(i+1), and swap."
% % CONF=2
% %@END

\subsection*{Code excerpt: shuffle loop}
\begin{lstlisting}
int rng_shuffle_groups(struct Rng *rng, size_t *values, size_t count)
{
	...
	if (count < 2)
		return 0;
	for (size_t i = 1; i < MAX_GROUPS; i++) {
		if (i >= count)
			break;
		size_t j = rng_range(rng, i + 1);
		size_t tmp = values[i];

		values[i] = values[j];
		values[j] = tmp;
	}
	return 0;
}

int rng_shuffle_items(struct Rng *rng, size_t *values, size_t count)
{
	...
	if (count < 2)
		return 0;
	for (size_t i = 1; i < MAX_ITEMS_PER_GROUP; i++) {
		if (i >= count)
			break;
		size_t j = rng_range(rng, i + 1);
		size_t tmp = values[i];

		values[i] = values[j];
		values[j] = tmp;
	}
	return 0;
}
\end{lstlisting}

Both shufflers are the same algorithm with different bounds. They begin at \off{i = 1}, not \off{i = 0}, because the \off{i = 0} iteration would be a no-op: the only legal \off{j} in \off{[0..0]} is \off{0}. Starting at \off{1} avoids a redundant call to \sym{rng\_range} without changing behavior.

The key correctness property is the \sym{rng\_range(rng, i + 1)} call. At step \off{i}, the code draws \off{j} uniformly from \off{[0..i]} and swaps \off{values[i]} with \off{values[j]}. That is exactly the modern Fisher--Yates step, so after processing \off{i}, the prefix \off{[0..i]} is uniformly shuffled.

The implementation also makes its bounds explicit in two ways. The loop’s upper limit is a hard maximum (\sym{MAX\_GROUPS} or \sym{MAX\_ITEMS\_PER\_GROUP}), and the runtime \sym{count} limit is enforced by \off{if (i >= count) break;}. Combined, those rules prevent out-of-bounds access even if a caller passes a \sym{count} near the configured maximum.

Finally, the early return \off{count < 2} documents a practical invariant: shuffling an empty list or a singleton is defined as success and performs no RNG draws. This matters for reproducibility when you are reasoning about the number of RNG calls in a run: you only pay for shuffle steps when there is something to shuffle.

\sowhat{The RNG module is intentionally narrow: it exposes just enough surface area to support shuffling and avoids “random utility” sprawl.}

%======================================================================
% CHAPTER 6
%======================================================================
\chapter{Terminal interface: \filep{src/term.c}}
\chapterroadmap{
This chapter explains how the program interacts with the terminal: raw mode, cursor control, screen clearing, and timed key reads.
}{
	\item Understand what “raw mode” means here.
	\item Understand how key reads are implemented with \sym{select}.
	\item Understand how ANSI escape sequences are written safely.
}

\section{Raw mode entry and restore}
\sym{term\_enter\_raw} obtains current settings with \sym{tcgetattr}, modifies them to disable canonical mode and echo, and applies them with \sym{tcsetattr}.

% %@RS[ID=SRC_RS_TERM_ISIG_CTRL_C_V1]
% % CLAIM="Raw mode disables ISIG, so Ctrl+C is read as byte 3 (ETX) instead of generating SIGINT; the runner treats key==3 as a clean exit."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="raw.c_lflag ISIG handle_key key == 3"
% % EVIDENCE="See term_enter_raw() excerpt below clearing ISIG and the handle_key() excerpt in Chapter 8 showing key==3 exit."
% % CONF=2
% %@END

\begin{evidenceblock}
{\sym{term\_enter\_raw} switches \off{STDIN} into a raw-ish mode by modifying \sym{termios} flags and setting \off{VMIN=0}, \off{VTIME=0}.}
{src/term.c}
{\sym{term\_enter\_raw}}
{If \sym{tcgetattr} or \sym{tcsetattr} fails, the error is formatted into a caller-provided buffer.}
\end{evidenceblock}

\begin{evidenceblock}
{Raw mode disables signal generation (\off{ISIG}) so Ctrl+C arrives as byte \off{3} (ETX) instead of generating SIGINT; the runner treats \off{key == 3} as a clean exit.}
{src/term.c, src/runner.c}
{\sym{term\_enter\_raw}, \sym{handle\_key}}
{\sym{term\_enter\_raw} clears \off{ISIG}; \sym{handle\_key} checks \off{key == 3} before any advance-key logic.}
\end{evidenceblock}

\subsection*{Code excerpt: raw termios flags}
\begin{lstlisting}
struct termios raw = state->original;

raw.c_lflag &= (tcflag_t)~(ECHO | ICANON | IEXTEN | ISIG);
raw.c_iflag &= (tcflag_t)~(IXON | ICRNL | BRKINT | INPCK | ISTRIP);
raw.c_oflag &= (tcflag_t)~(OPOST);
raw.c_cflag |= (CS8);
raw.c_cc[VMIN] = 0;
raw.c_cc[VTIME] = 0;

rc = tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
\end{lstlisting}

The most important flag in this excerpt is \off{ISIG}. Clearing it disables the terminal driver’s signal-generation behavior for special characters such as Ctrl+C. In canonical terminal modes, Ctrl+C typically generates SIGINT; here, it becomes just another byte delivered to the program’s input stream.

That design choice is what makes the runner’s exit logic deterministic and testable at the byte level. In Chapter 8, \sym{handle\_key} treats \off{key == 3} (ETX) as a clean exit request; with \off{ISIG} disabled, the runner reliably sees that byte instead of being asynchronously interrupted by a signal.

The remaining settings establish the “single-byte polling” contract used by the runtime loop: \off{ICANON} is cleared so input is not line-buffered, \off{ECHO} is cleared so typed characters are not echoed, and \off{VMIN=0}/\off{VTIME=0} make reads non-blocking (the blocking behavior is implemented explicitly via \sym{select} in \sym{term\_read\_key\_timeout}).

\begin{evidenceblock}
{\sym{term\_restore} is idempotent: if \sym{state->active} is false it returns success without calling \sym{tcsetattr}.}
{src/term.c}
{\sym{term\_restore}}
{On restore failure it clears \sym{state->active} and returns error.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_TERM_RESTORE_IDEMPOTENT_EXCERPT_V1]
% % CLAIM="term_restore returns success immediately when state->active is false; otherwise it calls tcsetattr and clears state->active regardless of success/failure."
% % STATE=UNVERIFIED
% % NEEDS_RESEARCH=YES
% % GAPS="Need excerpt showing the early return when !state->active and the 'state->active = 0' assignments on both the error and success paths."
% % NEXT_ACTION="Extract a 10–40 line excerpt from src/term.c covering term_restore(), including the active-flag checks, tcsetattr call, and state->active updates."
% % SEARCH_TERMS="int term_restore state->active if (!state->active) return 0 tcsetattr state->active = 0"
% % EVIDENCE="TODO: EX excerpt from src/term.c term_restore"
% % CONF=0
% %@END

\subsection*{Code excerpt: \sym{term\_restore} idempotency (TODO)}
\begin{lstlisting}
/* TODO: EXCERPT (10–40 lines) from src/term.c term_restore():
 * show: if (!state->active) return 0; and state->active cleared on both error and success.
 * SEARCH_TERMS: int term_restore if (!state->active) return 0 tcsetattr state->active = 0
 */
\end{lstlisting}

\section{Screen control}
The module provides cursor hide/show and a clear-screen operation by writing ANSI escape sequences to \off{STDOUT}.

\begin{evidenceblock}
{\sym{term\_clear\_screen}, \sym{term\_hide\_cursor}, and \sym{term\_show\_cursor} write ANSI escape sequences via \sym{write\_all}.}
{src/term.c}
{\sym{term\_clear\_screen}, \sym{term\_hide\_cursor}, \sym{term\_show\_cursor}}
{The sequences are \off{"\\textbackslash033[2J\\textbackslash033[H"}, \off{"\\textbackslash033[?25l"}, and \off{"\\textbackslash033[?25h"}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_TERM_WRITE_ALL_BOUNDED_LOOP_V1]
% % CLAIM="write_all retries write(STDOUT) up to MAX_WRITE_LOOPS, handles EINTR by retrying, and fails if it cannot write the full buffer."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="static int write_all MAX_WRITE_LOOPS errno == EINTR len != 0"
% % EVIDENCE="See write_all() excerpt below showing bounded writes, EINTR retry, and len!=0 failure."
% % CONF=2
% %@END

\subsection*{Code excerpt: bounded \sym{write\_all}}
\begin{lstlisting}
static int write_all(const char *buf, size_t len)
{
	if (!assert_ptr(buf))
		return -1;
	if (!assert_ok(len <= MAX_LINE_LEN))
		return -1;

	for (size_t i = 0; i < MAX_WRITE_LOOPS; i++) {
		if (len == 0)
			break;
		ssize_t n = write(STDOUT_FILENO, buf, len);

		if (n < 0) {
			if (errno == EINTR)
				continue;
			return -1;
		}
		if (n == 0)
			break;
		buf += (size_t)n;
		len -= (size_t)n;
	}
	if (len != 0)
		return -1;
	return 0;
}
\end{lstlisting}

\sym{write\_all} is a small but critical “best effort, but bounded” primitive. It attempts to write an entire buffer to \off{STDOUT} even if the kernel performs a short write, by advancing \sym{buf} and decrementing \sym{len} after each successful call.

The safety valve is the outer bound: the loop runs at most \sym{MAX\_WRITE\_LOOPS} iterations. This prevents pathological behavior in the face of repeated interruptions or unexpected \off{write(2)} behavior. In the normal case—escape sequences that fit in a few bytes—this bound is never approached.

Interruption handling is explicit. If \off{write} fails with \off{EINTR}, the function retries the same write without consuming any bytes. Any other error is treated as fatal.

Finally, the postcondition \off{len != 0 -> -1} makes the contract crisp: success means “every byte was written”, and failure means “some bytes may not have been written.” The screen-control functions build on this by propagating failures upward; they do not try to partially render escape sequences, which keeps terminal state changes atomic from the program’s point of view.

\section{Timed key reads}
\sym{term\_read\_key\_timeout} waits for readability with \sym{select} and then reads one byte from \off{STDIN}.

\begin{evidenceblock}
{\sym{term\_read\_key\_timeout} uses \sym{select} to wait for input and reads a single byte; it returns \off{1} when a key is read, \off{0} on timeout, and \off{-1} on error.}
{src/term.c}
{\sym{term\_read\_key\_timeout}}
{When \off{timeout\_ms} is \off{-1}, it blocks indefinitely by passing \off{NULL} timeout to \sym{select}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_TERM_TIMEOUT_NEG1_EXCERPT_V1]
% % CLAIM="term_read_key_timeout uses a NULL timeval pointer when timeout_ms < 0, and otherwise constructs tv_sec/tv_usec from timeout_ms."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="term_read_key_timeout timeout_ms >= 0 tv_ptr = &tv tv.tv_sec tv.tv_usec select("
% % EVIDENCE="See the term_read_key_timeout() excerpt below showing tv_ptr selection and select() call."
% % CONF=2
% %@END

\subsection*{Code excerpt: timeout=-1 selects NULL timeval}
\begin{lstlisting}
struct timeval tv;
struct timeval *tv_ptr = NULL;

if (timeout_ms >= 0) {
	tv.tv_sec = timeout_ms / 1000;
	tv.tv_usec = (timeout_ms % 1000) * 1000;
	tv_ptr = &tv;
}

int ready = select(STDIN_FILENO + 1, &readfds, NULL, NULL, tv_ptr);
\end{lstlisting}

This is the precise mechanism by which the rest of the program controls “polling vs blocking” reads. The function maintains a pointer \off{tv\_ptr} that is either \off{NULL} (meaning “wait forever”) or points to a stack-allocated \sym{struct timeval} (meaning “wait up to this long”).

When \off{timeout\_ms} is non-negative, the code computes \off{tv\_sec} and \off{tv\_usec} from milliseconds and passes \off{\&tv} to \sym{select}. That is how the runner implements “wake up and re-check timers”: it passes the remaining time until the current group expires.

When \off{timeout\_ms} is \off{-1}, the \off{timeout\_ms >= 0} branch is skipped and \off{tv\_ptr} stays \off{NULL}. \sym{select} then blocks indefinitely. This is the terminal-level primitive the runner uses once a group has expired and \sym{rt->pending\_switch} is set: it stops polling and sleeps until a key arrives.

\subsection*{Code excerpt: select/read}
\begin{lstlisting}
int ready = select(STDIN_FILENO + 1, &readfds, NULL, NULL, tv_ptr);
...
unsigned char ch = 0;
ssize_t n = read(STDIN_FILENO, &ch, 1);
if (n == 1) {
	*out_key = (int)ch;
	return 1;
}
\end{lstlisting}

% %@RS[ID=SRC_RS_TERM_EINTR_RETURNS_ZERO_V1]
% % CLAIM="term_read_key_timeout treats EINTR as 'no key yet' (returns 0) both for select() and for read()."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="ready < 0 errno == EINTR return 0 n < 0 && errno == EINTR"
% % EVIDENCE="See the term_read_key_timeout() excerpt below showing EINTR mapped to return 0 for both select() and read()."
% % CONF=2
% %@END

\subsection*{Code excerpt: EINTR semantics}
\begin{lstlisting}
int term_read_key_timeout(int timeout_ms, int *out_key)
{
	...
	int ready = select(STDIN_FILENO + 1, &readfds, NULL, NULL, tv_ptr);

	if (ready < 0) {
		if (errno == EINTR)
			return 0;
		return -1;
	}
	if (ready == 0)
		return 0;

	unsigned char ch = 0;
	ssize_t n = read(STDIN_FILENO, &ch, 1);

	if (n == 1) {
		*out_key = (int)ch;
		return 1;
	}
	if (n < 0 && errno == EINTR)
		return 0;
	return -1;
}
\end{lstlisting}

\sym{term\_read\_key\_timeout} uses a tri-state return convention: \off{1} means “a key was read”, \off{0} means “no key yet”, and \off{-1} means “hard error”. The EINTR handling in this excerpt shows that interruptions are deliberately mapped into the “no key yet” state.

On the \sym{select} side, \off{ready < 0} normally indicates a failure. But if \sym{errno == EINTR}, the function returns \off{0} instead of propagating an error. In other words, a signal interruption does not terminate the run or force a retry loop here; it simply behaves like an immediate timeout.

The same policy is applied to the \sym{read} call. If the input read is interrupted (\off{n < 0 \&\& errno == EINTR}), the function again returns \off{0}. This makes the read side consistent with the wait side: neither stage treats EINTR as exceptional.

That choice is practical for terminal programs. It keeps the caller’s control flow simple—call \sym{term\_read\_key\_timeout}, and treat \off{0} uniformly as “continue waiting/polling”—and it avoids accidentally turning transient signal noise into user-visible failures.

\sowhat{The terminal module is carefully scoped: it does not parse escape sequences or implement a UI framework; it only offers the primitives needed by the runtime loop.}

%======================================================================
% CHAPTER 7
%======================================================================
\chapter{Logging: \filep{src/log.c}}
\chapterroadmap{
This chapter explains the append-only log, its timestamping, and how logging failure is handled.
}{
	\item Understand where the log file is opened and where it lives.
	\item Understand the log line format.
	\item Understand the “logging is best-effort” behavior.
}

\section{Open/close lifecycle}
\sym{log\_open} attempts to open \filep{cram.log} with append semantics. If open fails, it prints a warning to stderr and continues with logging disabled.

% %@RS[ID=SRC_RS_LOG_OPEN_FAILURE_NONFATAL_V1]
% % CLAIM="If opening cram.log fails, log_open prints a warning to stderr and returns success, leaving logging disabled for the rest of the run."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="log_open open(\"cram.log\" Warning: failed to open cram.log g_log_fd < 0"
% % EVIDENCE="See the log_open() excerpt below showing the open() failure branch, warning write, and return 0."
% % CONF=2
% %@END

\begin{evidenceblock}
{\sym{log\_open} uses \sym{open("cram.log", O\_WRONLY | O\_CREAT | O\_APPEND, 0644)} and treats failure as non-fatal (prints a warning and returns success).}
{src/log.c}
{\sym{log\_open}}
{The global \sym{g\_log\_fd} remains negative when logging is disabled.}
\end{evidenceblock}

\subsection*{Code excerpt: \sym{log\_open} failure is non-fatal}
\begin{lstlisting}
g_log_fd = open("cram.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
if (g_log_fd < 0) {
	const char *err = strerror(errno);

	if (!err)
		err = "unknown error";
	char msg[256];
	int rc = snprintf(msg, sizeof(msg),
			  "Warning: failed to open cram.log: %s\n",
			  err);
	if (rc < 0 || (size_t)rc >= sizeof(msg))
		return -1;
	int wrc = write_all_fd(STDERR_FILENO, msg, (size_t)rc);

	if (wrc != 0)
		return -1;
	return 0;
}
return log_simple("start", "session started");
\end{lstlisting}

This excerpt shows the project’s logging philosophy in its most explicit form: logging is a best-effort side channel, not a dependency. \sym{log\_open} tries to open \filep{cram.log} for append. If that fails, it does \emph{not} fail the session; it formats a warning and writes it to \off{stderr}, then returns \off{0} (success) with \sym{g\_log\_fd} still negative.

The consequence is that the rest of the logging API becomes a no-op by convention. Other functions in \filep{src/log.c} check \sym{g\_log\_fd < 0} and return success without emitting output. This ensures the runtime loop does not have to thread “logging enabled?” through its logic; it simply calls \sym{log\_...} functions and relies on their internal guard.

There is also an error boundary inside the “non-fatal” path: if even the warning cannot be formatted or written (\sym{snprintf} failure or \sym{write\_all\_fd} failure), \sym{log\_open} returns \off{-1}. In other words, failing to open the log is acceptable; failing to report the failure is treated as a hard error.

\begin{evidenceblock}
{Most log functions return success without doing anything when \sym{g\_log\_fd < 0}.}
{src/log.c}
{\sym{log\_simple}, \sym{log\_key}, \sym{log\_prompt}, \sym{log\_group}, \sym{log\_shuffle}}
{This implements the “best-effort logging” policy.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_LOG_TAG_TAXONOMY_TODO_V1]
% % CLAIM="The set of log tags used by the program is small and enumerable from call sites, and documenting it improves auditability."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="log_simple( log_group( log_shuffle( log_prompt( log_key( \"start\" \"exit\" \"expired\" \"shuffle\" \"items\" \"error\""
% % EVIDENCE="See the table below; tag literals are visible in src/log.c, and runner-supplied tag literals appear in src/runner.c call sites."
% % CONF=2
% %@END

\subsection*{Log tag taxonomy}
\begin{evidenceblock}
{The log tag set is enumerable from literal strings in \filep{src/log.c} and a small set of tag literals passed by \filep{src/runner.c}.}
{src/log.c, src/runner.c}
{\sym{log\_open}, \sym{log\_close}, \sym{log\_key}, \sym{log\_prompt}, \sym{log\_group}, \sym{log\_shuffle}}
{Tags emitted by \filep{src/log.c}: \off{start}, \off{exit}, \off{key}, \off{prompt}. Tags supplied by the runner: \off{group}, \off{expired}, \off{shuffle}, \off{items}, \off{error}.}
\end{evidenceblock}

\subsection*{Code excerpt: \sym{log\_close} emits \off{exit}}
\begin{lstlisting}
int log_close(const struct Session *session)
{
	...
	if (g_log_fd < 0)
		return 0;

	int rc = log_simple("exit", "session end");

	if (rc != 0)
		return -1;
	rc = close(g_log_fd);
	...
	return 0;
}
\end{lstlisting}

\subsection*{Code excerpt: \sym{log\_key} and \sym{log\_prompt} tag literals}
\begin{lstlisting}
int log_key(int key)
{
	...
	if (g_log_fd < 0)
		return 0;
	...
	return log_write("key", msg);
}

int log_prompt(size_t group_index, size_t item_index)
{
	...
	if (g_log_fd < 0)
		return 0;
	...
	return log_write("prompt", msg);
}
\end{lstlisting}

\begin{longtable}{>{\raggedright\arraybackslash}p{0.18\linewidth} >{\raggedright\arraybackslash}p{0.32\linewidth} >{\raggedright\arraybackslash}p{0.42\linewidth}}
\textbf{Tag} & \textbf{Emitter(s)} & \textbf{Meaning / When it fires}\\\hline
\texttt{start} & \sym{log\_open} & Session begins; emitted only when the log file opens successfully.\\
\texttt{exit} & \sym{log\_close} & Session ends; emitted just before closing the log fd.\\
\texttt{key} & \sym{log\_key} (called by runner) & Raw key observed; message payload is \texttt{key=<decimal>}.\\
\texttt{prompt} & \sym{log\_prompt} (called by runner) & Prompt drawn; payload is \texttt{group=<g> item=<i>}.\\
\texttt{group} & \sym{log\_group("group", ...)} (runner) & Group switch applied; payload is \texttt{group=<g>}.\\
\texttt{expired} & \sym{log\_group("expired", ...)} (runner) & Group timer expired; payload is \texttt{group=<g>}; switch becomes pending.\\
\texttt{shuffle} & \sym{log\_simple("shuffle", "groups")} (runner) & Group order reshuffled; payload is the literal \texttt{groups}.\\
\texttt{items} & \sym{log\_shuffle("items", ...)} (runner) & Item order reshuffled for a group; payload is \texttt{group=<g>}.\\
\texttt{error} & \sym{log\_simple("error", "wait loop exceeded")} (runner) & Bounded wait loop exceeded without advancing; session fails.\\
\end{longtable}

\section{Timestamp and line format}
\sym{log\_write} timestamps with \off{CLOCK\_REALTIME} and formats lines like:
\begin{quote}\small\sloppy
\texttt{<unix\_seconds>.<milliseconds> [<tag>] <message>}
\end{quote}

\begin{evidenceblock}
{Log lines include realtime seconds and milliseconds and use \texttt{[\%s]} tag framing.}
{src/log.c}
{\sym{log\_write}}
{The format string is \texttt{"\%llu.\%03llu [\%s] \%s\textbackslash n"}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_LOG_WRITE_CLOCK_REALTIME_V1]
% % CLAIM="log_write timestamps using clock_gettime(CLOCK_REALTIME) and writes the formatted line to the log fd using a bounded EINTR-retrying loop."
% % STATE=UNVERIFIED
% % NEEDS_RESEARCH=YES
% % GAPS="Need excerpt showing clock_gettime(CLOCK_REALTIME, &ts) error handling and the MAX_WRITE_LOOPS write() loop with EINTR retry."
% % NEXT_ACTION="Extract a 10–40 line excerpt from src/log.c log_write() covering the clock_gettime call and the write loop (including errno==EINTR continue)."
% % SEARCH_TERMS="static int log_write clock_gettime(CLOCK_REALTIME MAX_WRITE_LOOPS errno == EINTR write(g_log_fd"
% % EVIDENCE="TODO: EX excerpt from src/log.c log_write clock_gettime/write loop"
% % CONF=0
% %@END

\subsection*{Code excerpt: formatting a log line}
\begin{lstlisting}
u64 sec = (u64)ts.tv_sec;
u64 ms = (u64)(ts.tv_nsec / 1000000L);
char line[256];

rc = snprintf(line, sizeof(line), "%llu.%03llu [%s] %s\n",
	      (unsigned long long)sec,
	      (unsigned long long)ms, tag, msg);
\end{lstlisting}

\subsection*{Code excerpt: clock\_gettime and bounded write (TODO)}
\begin{lstlisting}
/* TODO: EXCERPT (10–40 lines) from src/log.c log_write():
 * show: clock_gettime(CLOCK_REALTIME, &ts) and the MAX_WRITE_LOOPS write() loop with errno==EINTR retry.
 * SEARCH_TERMS: clock_gettime(CLOCK_REALTIME MAX_WRITE_LOOPS errno == EINTR write(g_log_fd
 */
\end{lstlisting}

\sowhat{Logging is designed to never prevent the program from running; it is for post-mortem understanding and auditing, not correctness.}

%======================================================================
% CHAPTER 8
%======================================================================
\chapter{The runtime loop: \filep{src/runner.c}}
\chapterroadmap{
This chapter is the core: how prompts are displayed, how timers and group switches work, and how key input drives state transitions.
}{
	\item Understand the runtime state machine (\sym{struct runtime}).
	\item Understand group selection and item selection.
	\item Understand the “pending switch” mechanism.
}

\section{Runtime state and context}
\filep{src/runner.c} separates:
\begin{itemize}
	\item \sym{struct ctx}: pointers to shared inputs (session, rng, scratch arrays).
	\item \sym{struct runtime}: mutable runtime state (current indices, timers, flags).
\end{itemize}

\begin{evidenceblock}
{The runtime loop separates immutable-ish context (\sym{struct ctx}) from mutable run state (\sym{struct runtime}).}
{src/runner.c}
{\sym{struct ctx}, \sym{struct runtime}}
{This keeps parameter lists small and makes state flow explicit.}
\end{evidenceblock}

\section{Timekeeping}
Group timing uses \off{CLOCK\_MONOTONIC} measured in milliseconds; logging timestamps are separate (they use \off{CLOCK\_REALTIME} in \filep{src/log.c}).

\begin{evidenceblock}
{Group timers use \off{CLOCK\_MONOTONIC} converted to milliseconds via \sym{now\_ms}.}
{src/runner.c}
{\sym{now\_ms}, \sym{update\_group\_timer}}
{\sym{update\_group\_timer} sets \sym{rt->group\_end = now + seconds*1000}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_RUNNER_GROUP_END_COMPUTATION_V1]
% % CLAIM="update_group_timer reads the current group’s seconds duration and sets rt->group_end to now_ms() + seconds*1000, relying on the parser’s MAX_GROUP_SECONDS bound to keep durations sane."
% % STATE=UNVERIFIED
% % NEEDS_RESEARCH=YES
% % GAPS="Need excerpt showing update_group_timer reading group->seconds, calling now_ms, and setting rt->group_end = now + (u64)seconds * 1000ULL."
% % NEXT_ACTION="Extract a 10–40 line excerpt from src/runner.c covering update_group_timer(), including the seconds read, now_ms call, and group_end assignment."
% % SEARCH_TERMS="static int update_group_timer seconds = c->session->groups[rt->group_index].seconds now_ms rt->group_end = now + (u64)seconds * 1000ULL"
% % EVIDENCE="TODO: EX excerpt from src/runner.c update_group_timer"
% % CONF=0
% %@END

\subsection*{Code excerpt: group\_end computation (TODO)}
\begin{lstlisting}
/* TODO: EXCERPT (10–40 lines) from src/runner.c update_group_timer():
 * show seconds read, now_ms call, and rt->group_end assignment.
 * SEARCH_TERMS: update_group_timer group_end seconds * 1000ULL now_ms
 */
\end{lstlisting}

\section{Group order and item order}
The runner maintains two independent shuffled sequences:
\begin{itemize}
	\item \textbf{Group order}: a permutation of group indices, reshuffled when exhausted.
	\item \textbf{Item order}: a permutation of item indices within the current group, reshuffled when exhausted.
\end{itemize}

\begin{evidenceblock}
{When the group order is exhausted, the runner reshuffles the group order and resets \sym{rt->order\_pos}.}
{src/runner.c}
{\sym{select\_next\_group}}
{The reshuffle is logged via \sym{log\_simple("shuffle", "groups")}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_RUNNER_GROUP_SHUFFLE_EXCERPT_V1]
% % CLAIM="select_next_group reshuffles group_order when order_pos reaches group_count, logs the 'shuffle'/'groups' event, and then consumes the next group index."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="select_next_group order_pos >= session->group_count rng_shuffle_groups log_simple(\"shuffle\", \"groups\")"
% % EVIDENCE="See the select_next_group() excerpt below showing the reshuffle+log branch and the consumption of group_order[order_pos]."
% % CONF=2
% %@END

\subsection*{Code excerpt: group reshuffle on exhaustion}
\begin{lstlisting}
static int select_next_group(const struct ctx *c, struct runtime *rt)
{
	...
	if (rt->order_pos >= c->session->group_count) {
		int rc = rng_shuffle_groups(c->rng, c->group_order,
					 c->session->group_count);
		if (rc != 0)
			return -1;
		rt->order_pos = 0;
		rc = log_simple("shuffle", "groups");
		if (rc != 0)
			return -1;
	}
	rt->group_index = c->group_order[rt->order_pos];
	rt->order_pos++;
	return 0;
}
\end{lstlisting}

This function is the “group iterator” for the runtime loop. It uses a scratch array (\sym{group\_order}) as a permutation of group indices and a cursor (\sym{rt->order\_pos}) that points at the next index to consume.

The exhaustion check is explicit: when \sym{order\_pos} reaches \sym{group\_count}, the order array is reshuffled in-place by \sym{rng\_shuffle\_groups} and the cursor is reset to zero. Immediately after reshuffling, the code logs a \off{shuffle} event with payload \off{groups}. (If logging is disabled, \sym{log\_simple} is a no-op and the runtime proceeds unchanged.)

Only after ensuring there is a valid next slot does the function read \sym{group\_order[order\_pos]} into \sym{rt->group\_index} and advance the cursor. That separation (reshuffle/prepare, then consume) is what gives the program its “no repeats until exhausted” behavior at the group level without needing any dynamic memory or per-group bookkeeping.

\begin{evidenceblock}
{When items in a group are exhausted, the runner reshuffles that group’s item order and logs an \off{items} shuffle event.}
{src/runner.c}
{\sym{advance\_prompt}}
{On wraparound it calls \sym{rng\_shuffle\_items} and \sym{log\_shuffle("items", group\_index)}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_RUNNER_ITEM_SHUFFLE_WRAP_EXCERPT_V1]
% % CLAIM="advance_prompt increments item_pos; when it reaches the group item_count it reshuffles item_order, logs an 'items' shuffle event, and wraps item_pos to zero."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="advance_prompt rt->item_pos++ rt->item_pos >= count rng_shuffle_items log_shuffle(\"items\""
% % EVIDENCE="See the advance_prompt() excerpt below showing the wraparound reshuffle and log_shuffle(\"items\", ...)."
% % CONF=2
% %@END

\subsection*{Code excerpt: item reshuffle on wraparound}
\begin{lstlisting}
if (due_to_switch) {
	...
} else {
	rt->item_pos++;
	if (rt->item_pos >= count) {
		int rc = rng_shuffle_items(c->rng, c->item_order,
				   count);
		if (rc != 0)
			return -1;
		rt->item_pos = 0;
		rc = log_shuffle("items", rt->group_index);
		if (rc != 0)
			return -1;
	}
}
\end{lstlisting}

The runner uses \sym{rt->item\_pos} as a cursor into the current group’s shuffled item order. For the normal “stay in the same group” path (\off{due\_to\_switch == 0}), it increments the cursor on every advance.

The wraparound condition is checked against the group’s runtime item count (\off{count}). When the cursor reaches \off{count}, the code immediately reshuffles the item-order array in place via \sym{rng\_shuffle\_items}, resets \sym{rt->item\_pos} to zero, and emits a log event tagged \off{items} for the current group index.

This is the item-level analogue of the group-order exhaustion logic: within a group, you get a full pass through the current permutation before repeats occur, and the “next cycle” boundary is both explicit in the code and observable in \filep{cram.log} when logging is enabled.

\section{The “pending switch” mechanism}
The key detail is that group expiry does not immediately switch groups. Instead:
\begin{itemize}
	\item When the timer expires, the runner marks \sym{rt->pending\_switch = 1}.
	\item The next \emph{advance key} applies the group switch, then advances.
\end{itemize}

\begin{evidenceblock}
{Timer expiry sets \sym{rt->pending\_switch = 1} and logs an \off{expired} event, but does not switch groups immediately.}
{src/runner.c}
{\sym{update\_expiry}}
{The “pending switch” flag defers the group switch until the next advance key.}
\end{evidenceblock}

\subsection*{Code excerpt: expiry handling}
\begin{lstlisting}
if (now >= rt->group_end) {
	rt->pending_switch = 1;
	rc = log_group("expired", rt->group_index);
	if (rc != 0)
		return -1;
	return 0;
}
\end{lstlisting}

% %@RS[ID=SRC_RS_RUNNER_PENDING_SWITCH_BLOCKING_V1]
% % CLAIM="When a group has expired and pending_switch is set, the runner stops polling with timeouts and instead blocks indefinitely for the next key (timeout=-1)."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="read_key pending_switch ? -1 term_read_key_timeout"
% % EVIDENCE="See read_key() excerpt below (timeout = pending_switch ? -1 : remaining_ms)."
% % CONF=2
% %@END

\begin{evidenceblock}
{When \sym{rt->pending\_switch} is set, \sym{read\_key} uses \off{timeout = -1}, so the program blocks indefinitely waiting for a key rather than polling.}
{src/runner.c}
{\sym{read\_key}}
{The timeout is computed as \off{rt->pending\_switch ? -1 : (int)remaining\_ms}.}
\end{evidenceblock}

\subsection*{Code excerpt: pending-switch timeout=-1}
\begin{lstlisting}
static int read_key(const struct ctx *c, const struct runtime *rt,
		    u64 remaining_ms, int *key_out)
{
	if (!validate_ptr(c))
		return -1;
	if (!validate_ptr(rt))
		return -1;
	if (!validate_ptr(key_out))
		return -1;
	if (!validate_ok(remaining_ms <= 86400000ULL))
		return -1;

	int timeout = rt->pending_switch ? -1 : (int)remaining_ms;
	int rc = term_read_key_timeout(timeout, key_out);

	if (rc < 0)
		return -1;
	return rc;
}
\end{lstlisting}

The runner’s normal behavior is time-bounded polling: it computes \off{remaining\_ms} until the current group expires, then passes that as a timeout to \sym{term\_read\_key\_timeout}. A return value of \off{0} means “no key yet”; the runtime loops, recomputes time remaining, and tries again.

When \sym{rt->pending\_switch} is set, this behavior intentionally changes. The excerpt shows \sym{read\_key} forcing \off{timeout = -1}. In \filep{src/term.c}, \sym{term\_read\_key\_timeout} treats \off{-1} as “wait forever” by calling \sym{select} with a \off{NULL} timeout. This guarantees that, once the group has expired, the program is no longer waking up just to notice the passage of time; it sleeps until the user presses a key.

This choice is part of the contract implied by the phrase “group changes only apply after the timer expires and you press a key”: expiry is detected by \sym{update\_expiry}, but the user’s next advance key is what triggers the switch path in \sym{handle\_key}.

\begin{evidenceblock}
{If \sym{rt->pending\_switch} is set and an advance key is pressed, the runner selects the next group and advances due to switch.}
{src/runner.c}
{\sym{handle\_key}, \sym{select\_next\_group}, \sym{advance\_prompt}}
{\sym{advance\_prompt} reinitializes and reshuffles item order when switching groups.}
\end{evidenceblock}

\subsection*{Code excerpt: applying a pending switch}
\begin{lstlisting}
if (rt->pending_switch) {
	rc = select_next_group(c, rt);
	if (rc != 0)
		return -1;
	rt->pending_switch = 0;
	rc = advance_prompt(c, rt, 1);
	if (rc != 0)
		return -1;
}
\end{lstlisting}

\section{Key handling and exit}
Key handling is intentionally simple:
\begin{itemize}
	\item \off{Ctrl+C} (byte value \off{3}) causes the runner to exit successfully.
	\item Space, Enter, and alphanumeric characters advance.
	\item Other keys are ignored (but still logged when logging is enabled).
\end{itemize}

\begin{evidenceblock}
{\sym{handle\_key} treats key \off{3} as an exit request and considers space, newline, carriage return, and alphanumerics as “advance keys”.}
{src/runner.c}
{\sym{handle\_key}, \sym{is\_advance\_key}}
{\sym{handle\_key} logs every key via \sym{log\_key} before interpreting it.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_RUNNER_KEY_CLASSIFICATION_V1]
% % CLAIM="The runner logs every key, exits when key==3, advances only on space/CR/LF/alnum, and otherwise ignores input."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="handle_key log_key key == 3 is_advance_key"
% % EVIDENCE="See handle_key() excerpt below showing log-first ordering, Ctrl+C exit, and advance-key filtering."
% % CONF=2
% %@END

\begin{evidenceblock}
{The runner always logs the key before interpreting it; Ctrl+C exits immediately; only a small set of “advance keys” trigger an advance.}
{src/runner.c}
{\sym{handle\_key}}
{The ordering is \sym{log\_key} \(\rightarrow\) \off{key == 3} exit \(\rightarrow\) \sym{is\_advance\_key} filter \(\rightarrow\) advance.}
\end{evidenceblock}

\subsection*{Code excerpt: key handling order}
\begin{lstlisting}
static int handle_key(const struct ctx *c, struct runtime *rt,
		      int key, int *advanced)
{
	...
	int rc = log_key(key);

	if (rc != 0)
		return -1;
	if (key == 3)
		return 1;
	if (!is_advance_key(key))
		return 0;
	...
	*advanced = 1;
	return 0;
}
\end{lstlisting}

The ordering matters because it defines what ends up in \filep{cram.log}. The call to \sym{log\_key} happens \emph{before} any control-flow decision, which means keys that do nothing (non-advance keys) are still recorded, and keys that terminate the session (Ctrl+C) are also recorded (assuming logging is enabled).

The early \off{key == 3} return is the program’s exit convention: it treats byte value \off{3} (ETX, the usual Ctrl+C character) as a clean shutdown request and returns a positive value to its caller to break out of the wait loop without signaling an error.

Finally, the \sym{is\_advance\_key} gate enforces a small vocabulary of “advance” inputs. Everything else is ignored intentionally: the runtime does not try to interpret arrow keys or escape sequences as commands. This keeps the loop’s state machine simple and makes it hard to accidentally add UI surface area without touching \sym{is\_advance\_key} on purpose.

\section{Terminal lifecycle}
The runtime enters raw mode and hides the cursor before running the loop; on exit it restores the terminal, shows the cursor, and clears the screen.

\begin{evidenceblock}
{The runner wraps the loop in a “terminal session”: enter raw mode, hide cursor, run loop, restore terminal, show cursor, clear screen.}
{src/runner.c}
{\sym{run\_with\_terminal}}
{Restore/show/clear are asserted to succeed before returning.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_RUNNER_TERMINAL_CLEANUP_ORDER_EXCERPT_V1]
% % CLAIM="run_with_terminal always attempts to restore the terminal and show the cursor on exit, even if the loop fails; hide cursor failure short-circuits running the loop."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="run_with_terminal hide_rc term_hide_cursor term_restore term_show_cursor term_clear_screen assert_ok"
% % EVIDENCE="See run_with_terminal() excerpt below showing hide_rc gating and restore/show/clear assertions."
% % CONF=2
% %@END

\subsection*{Code excerpt: terminal cleanup order}
\begin{lstlisting}
static int run_with_terminal(const struct ctx *c, struct runtime *rt)
{
	if (!validate_ptr(c))
		return -1;
	if (!validate_ptr(rt))
		return -1;

	char err_buf[256];
	struct TermState term = {0};
	int rc = term_enter_raw(&term, err_buf, sizeof(err_buf));

	if (rc != 0) {
		rc = fprintf(stderr, "Error: %s\n", err_buf);
		if (rc < 0)
			return -1;
		return -1;
	}

	int hide_rc = term_hide_cursor();
	int loop_rc = -1;

	if (hide_rc == 0)
		loop_rc = run_loop(c, rt);

	int restore_rc = term_restore(&term);
	int show_rc = term_show_cursor();
	int clear_rc = term_clear_screen();

	if (!assert_ok(restore_rc == 0))
		return -1;
	if (!assert_ok(show_rc == 0))
		return -1;
	if (!assert_ok(clear_rc == 0))
		return -1;

	if (hide_rc != 0)
		return -1;
	return loop_rc;
}
\end{lstlisting}

This wrapper function is the book’s strongest guarantee about “terminal hygiene”. The key observation is the ordering: raw mode is entered first, then the cursor is hidden, then (and only then) the interactive loop runs.

The \sym{hide\_rc} gate is important. If \sym{term\_hide\_cursor} fails, the program does \emph{not} attempt to run the prompt loop at all; it proceeds straight to cleanup. That choice keeps failure modes easy to reason about: the loop only runs in the “fully-initialized” terminal state (raw + cursor hidden).

Regardless of whether \sym{run\_loop} succeeds or fails, the function always calls \sym{term\_restore}, \sym{term\_show\_cursor}, and \sym{term\_clear\_screen} before deciding what to return. In other words, terminal restoration is not conditional on the loop’s return code.

Finally, the \sym{assert\_ok} checks mean cleanup is treated as non-negotiable: if any restoration step fails, \sym{run\_with\_terminal} returns an error. That design is conservative (it can mask the original loop error), but it reflects the practical priority in terminal programs: leave the user’s TTY in a usable state, even when the session itself did not complete successfully.

\section{Bounded wait loop and failure behavior}
\sym{run\_wait\_loop} iterates up to \sym{MAX\_WAIT\_LOOPS} times. If it cannot make progress (no advance) within that bound, it logs \off{wait loop exceeded} and fails.

% %@RS[ID=SRC_RS_RUNNER_WAIT_LOOP_EXCEEDED_V1]
% % CLAIM="If run_wait_loop returns without advancing, run_loop logs an 'error' tag with message 'wait loop exceeded' and returns failure."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="run_loop !advanced log_simple(\"error\", \"wait loop exceeded\")"
% % EVIDENCE="See run_loop() excerpt below showing log_simple(\"error\", \"wait loop exceeded\")."
% % CONF=2
% %@END

\begin{evidenceblock}
{The runtime uses bounded loops controlled by \sym{MAX\_PROMPTS\_PER\_RUN} and \sym{MAX\_WAIT\_LOOPS}; exceeding the wait loop logs an error and returns failure.}
{include/config.h, src/runner.c}
{\sym{MAX\_PROMPTS\_PER\_RUN}, \sym{MAX\_WAIT\_LOOPS}, \sym{run\_wait\_loop}, \sym{run\_loop}}
{\sym{run\_loop} logs \off{error: wait loop exceeded} when \sym{run\_wait\_loop} returns without advancing.}
\end{evidenceblock}

\subsection*{Code excerpt: wait-loop exceeded failure}
\begin{lstlisting}
static int run_loop(const struct ctx *c, struct runtime *rt)
{
	...
	for (size_t step = 1; step < MAX_PROMPTS_PER_RUN; step++) {
		int advanced = 0;
		int rc = run_wait_loop(c, rt, &advanced);

		if (rc < 0)
			return -1;
		if (rc > 0)
			return 0;
		if (!advanced) {
			rc = log_simple("error", "wait loop exceeded");
			if (rc != 0)
				return -1;
			return -1;
		}
	}
	return 0;
}
\end{lstlisting}

The core runtime loop (\sym{run\_loop}) is intentionally structured as a “progress machine”: each iteration should either (a) observe an exit request, (b) advance to another prompt, or (c) fail. The variable \off{advanced} is the local witness for (b): it is only set when \sym{handle\_key} executes an advance path.

In the normal case, \sym{run\_wait\_loop} polls until it reads a key, then \sym{handle\_key} decides whether that key implies an advance. If it does, \off{advanced} becomes true and the outer loop continues to the next \off{step}.

The excerpt also shows the “escape hatch” for pathological behavior: if \sym{run\_wait\_loop} returns without advancing, \sym{run\_loop} writes an explicit error record (\off{tag=error}, \off{msg=wait loop exceeded}) and returns failure. This is the codebase’s defensive posture in miniature: even “should never happen” loops have a bounded way to fail, and they try to leave a forensic breadcrumb in \filep{cram.log} when available.

\sowhat{Most “what does it do when…” questions are answered in \filep{src/runner.c}: the state machine is explicit and the only implicit behavior comes from system calls (select, read, clock).}

%======================================================================
% CHAPTER 9
%======================================================================
\chapter{Wiring and ownership: \filep{src/app.c} and \filep{src/main.c}}
\chapterroadmap{
This chapter explains where long-lived state lives and how errors are surfaced to the user.
}{
	\item Identify the owner of \sym{struct Session} and scratch buffers.
	\item Understand error reporting conventions at process boundaries.
	\item Understand what gets freed (nothing) and why that is OK here.
}

\section{Static app state}
\filep{src/app.c} defines a private \sym{struct app} holding:
\begin{itemize}
	\item The \sym{struct Session} (parsed model + backing buffer).
	\item The RNG state.
	\item Scratch arrays for group and item order.
\end{itemize}
This struct is allocated as a single static global (\sym{g\_app}).

\begin{evidenceblock}
{The program’s long-lived state lives in a single static global \sym{g\_app} that contains the session, RNG, and scratch order arrays.}
{src/app.c}
{\sym{struct app}, \sym{g\_app}}
{The order arrays are sized by \sym{MAX\_GROUPS} and \sym{MAX\_ITEMS\_PER\_GROUP}.}
\end{evidenceblock}

% %@RS[ID=SRC_RS_APP_GLOBAL_LAYOUT_EXCERPT_V1]
% % CLAIM="The app-level state is a static global struct containing the Session, Rng, and fixed-size order arrays; this defines lifetimes and avoids heap allocation."
% % STATE=VERIFIED
% % NEEDS_RESEARCH=NO
% % GAPS="None."
% % NEXT_ACTION="None."
% % SEARCH_TERMS="struct app { struct Session static struct app g_app group_order item_order"
% % EVIDENCE="See excerpt below showing struct app layout and the static g_app allocation."
% % CONF=2
% %@END

\subsection*{Code excerpt: app global layout}
\begin{lstlisting}
struct app {
	struct Session session;
	struct Rng rng;
	size_t group_order[MAX_GROUPS];
	size_t item_order[MAX_ITEMS_PER_GROUP];
};

static struct app g_app;
\end{lstlisting}

This is the codebase’s ownership model in its simplest form: the entire program state is a single static global, and every subsystem operates on references into that global. There is no heap allocation in the steady-state path because the major buffers (session text, parsed groups/items, and order scratch space) are all compile-time sized by \filep{include/config.h}.

The two order arrays (\sym{group\_order} and \sym{item\_order}) are the runner’s scratch space for shuffling and iteration. Keeping them inside \sym{g\_app} makes their lifetime “whole process” without requiring any explicit init/free logic, which aligns with the CLI-like nature of the program (parse one file, run, exit).

The tradeoff is that the configuration bounds become architectural: \sym{MAX\_GROUPS} and \sym{MAX\_ITEMS\_PER\_GROUP} are not merely parser limits, they also determine the memory footprint of the process. That is consistent with the overall philosophy seen throughout the repo: prefer predictable, bounded resource usage and simple lifetimes over dynamic growth and complex cleanup.

\section{Error reporting strategy}
The boundary between “library-ish code” and “CLI user” is mostly at \filep{src/main.c} and \filep{src/app.c}:
\begin{itemize}
	\item \filep{src/main.c} prints usage to \off{stdout} and returns distinct exit codes for usage vs usage-print failure.
	\item \filep{src/app.c} prints parse errors to \off{stderr} using the parser’s error buffer.
\end{itemize}

\begin{evidenceblock}
{\filep{src/main.c} prints usage and uses distinct exit codes for usage errors vs usage-print failure.}
{src/main.c}
{\sym{print\_usage}, \sym{main}}
{\sym{main} returns \off{2} if printing usage fails when handling a usage error.}
\end{evidenceblock}

\begin{evidenceblock}
{Parse errors are formatted by the parser into an error buffer and printed to stderr by \filep{src/app.c}.}
{src/app.c, src/parser.c}
{\sym{setup\_session}, \sym{parse\_session\_file}}
{\sym{setup\_session} prints \off{"Error: <msg>\\textbackslash n"} on failure.}
\end{evidenceblock}

\sowhat{If you want to change what the program does, most changes should land in a single module; if you want to change how modules compose, \filep{src/app.c} is the place.}

%======================================================================
% APPENDIX
%======================================================================
\appendix
\chapter{Practical modification points (without changing the architecture)}
\purpose{List changes you can make safely, and where you should make them, without turning this codebase into a framework.}

\section{Behavior changes}
\begin{itemize}
	\item Change what counts as an “advance” key: edit \sym{is\_advance\_key} in \filep{src/runner.c}.
	\item Change switching semantics: inspect \sym{update\_expiry} and \sym{handle\_key} in \filep{src/runner.c}.
	\item Change file format rules: inspect \sym{handle\_line} and \sym{parse\_header\_line} in \filep{src/parser.c}.
	\item Change logging tags or payloads: inspect \sym{log\_key}, \sym{log\_prompt}, and \sym{log\_group} in \filep{src/log.c}.
\end{itemize}

\section{Footprint and bounds}
The correct lever for memory footprint and maximum accepted sizes is \filep{include/config.h}. The constants affect:
\begin{itemize}
	\item The size of \sym{struct Session} (buffer/groups/items arrays).
	\item The maximum iterations of key loops and write loops.
\end{itemize}

\pitfall{Raising limits}{Increasing \sym{MAX\_...} constants increases static memory and can make the program unusable on constrained machines. The code assumes these are “large but finite”, not “infinite”.}

\section{Verification procedures}
The document describes behavior precisely, but it currently lacks a concrete “do this and observe that” checklist. The most important verification tasks should be reproducible with the existing binary and the existing example files in \filep{examples/}.

% %@RS[ID=SRC_RS_VERIFICATION_CHECKLIST_V1]
% % CLAIM="A reader can validate key runtime semantics (pending-switch, wait-loop bounds, logging tags) by running the program on examples/ and inspecting the emitted cram.log."
% % STATE=UNVERIFIED
% % NEEDS_RESEARCH=YES
% % GAPS="Need a step-by-step verification checklist with exact commands and expected observable outputs (log tags/ordering), without adding new tooling."
% % NEXT_ACTION="Draft a short verification subsection in the appendix with commands like './cram examples/times_tables' and concrete checks in cram.log (presence/order of start/prompt/key/expired/group/exit). Confirm actual log contents by running locally."
% % SEARCH_TERMS="examples/times_tables cram.log start prompt key expired group exit wait loop exceeded"
% % EVIDENCE="TODO: Add a verification checklist and, optionally, a small sample log excerpt."
% % CONF=0
% %@END

\begin{lstlisting}
TODO: VERIFICATION CHECKLIST (reader-facing)

1) Basic run produces a log:
   - Run: ./cram examples/times_tables
   - Expect: cram.log exists and begins with a [start] line and later [exit]

2) Key logging:
   - Press a few keys; expect [key] entries with decimal codes

3) Expiry and pending-switch:
   - Wait for a group to expire; expect [expired] then, after the next advance key, a [group] switch event

4) Shuffle events:
   - Run long enough; expect [shuffle] groups and [items] events
\end{lstlisting}

\end{document}
